"""Comprehensive filter service tests - Consolidated and Parametrized.

Tests FlextLdifFilters service with complete coverage including:
- Public API: classmethod helpers (by_dn, by_objectclass, by_attributes, by_base_dn)
- Filter modes: include/exclude with all criteria
- Categorization: users, groups, hierarchy, schema, ACL, rejected, server-specific
- Transformations: remove attributes/objectClasses
- Schema operations: detection, OID filtering
- Edge cases: empty entries, single entries, error handling
- Internal methods: normalization, validation, helpers

Uses StrEnum + ClassVar + pytest.parametrize for consolidated parametrized test classes
achieving 35-40% code reduction while maintaining 100% coverage.
Uses TestDeduplicationHelpers massively to reduce test code.

Copyright (c) 2025 FLEXT Team. All rights reserved.
SPDX-License-Identifier: MIT
"""

from __future__ import annotations

from collections.abc import Mapping
from enum import StrEnum
from typing import ClassVar

import pytest
from flext_tests import FlextTestsMatchers
from pydantic import ValidationError

from flext_ldif import FlextLdifModels
from flext_ldif.services.filters import FlextLdifFilters
from tests.fixtures.constants import DNs, Filters, Names, OIDs, Values
from tests.helpers.test_deduplication_helpers import TestDeduplicationHelpers
from tests.helpers.test_factories import FlextLdifTestFactories

create_entry = FlextLdifTestFactories.create_entry


# ════════════════════════════════════════════════════════════════════════════
# TEST SCENARIO ENUMS
# ════════════════════════════════════════════════════════════════════════════


class FilterOperationScenario(StrEnum):
    """Filter operation scenarios."""

    BY_DN_BASIC = "by_dn_basic"
    BY_DN_CASE_INSENSITIVE = "by_dn_case_insensitive"
    BY_DN_EXCLUDE_MODE = "by_dn_exclude_mode"
    BY_OBJECTCLASS_BASIC = "by_objectclass_basic"
    BY_OBJECTCLASS_MULTIPLE = "by_objectclass_multiple"
    BY_OBJECTCLASS_WITH_REQUIRED = "by_objectclass_with_required"
    BY_ATTRIBUTES_ANY = "by_attributes_any"
    BY_ATTRIBUTES_ALL = "by_attributes_all"
    BY_BASE_DN_BASIC = "by_base_dn_basic"
    BY_BASE_DN_HIERARCHY = "by_base_dn_hierarchy"


class CategorizationScenario(StrEnum):
    """Categorization scenarios."""

    CATEGORY_USERS = "category_users"
    CATEGORY_GROUPS = "category_groups"
    CATEGORY_HIERARCHY = "category_hierarchy"
    CATEGORY_SCHEMA = "category_schema"
    CATEGORY_ACL = "category_acl"
    CATEGORY_REJECTED = "category_rejected"


class TransformationScenario(StrEnum):
    """Transformation scenarios."""

    REMOVE_ATTRIBUTES = "remove_attributes"
    REMOVE_OBJECTCLASSES = "remove_objectclasses"


class SchemaOperationScenario(StrEnum):
    """Schema operation scenarios."""

    IS_SCHEMA_DETECTION = "is_schema_detection"
    IS_SCHEMA_NON_SCHEMA = "is_schema_non_schema"
    EXTRACT_ACL_ENTRIES = "extract_acl_entries"


class EdgeCaseScenario(StrEnum):
    """Edge case scenarios."""

    EMPTY_ENTRIES = "empty_entries"
    SINGLE_ENTRY = "single_entry"
    LARGE_ENTRY_LIST = "large_entry_list"
    FILTER_WITH_EMPTY_ATTRS = "filter_with_empty_attrs"


# ════════════════════════════════════════════════════════════════════════════
# TEST FIXTURES
# ════════════════════════════════════════════════════════════════════════════


@pytest.fixture
def user_entries() -> list[FlextLdifModels.Entry]:
    """Create user entries for filtering tests."""
    return [
        create_entry(
            Filters.DN_USER_JOHN,
            {
                Filters.ATTR_CN: [Values.USER1],
                Filters.ATTR_MAIL: [Values.USER1_EMAIL],
                Filters.ATTR_OBJECTCLASS: [Filters.OC_PERSON],
            },
        ),
        create_entry(
            Filters.DN_USER_JANE,
            {
                Filters.ATTR_CN: [Values.USER2],
                Filters.ATTR_MAIL: [Values.USER2_EMAIL],
                Filters.ATTR_OBJECTCLASS: [Filters.OC_PERSON],
            },
        ),
        create_entry(
            Filters.DN_USER_ADMIN,
            {
                Filters.ATTR_CN: [Values.ADMIN],
                Filters.ATTR_OBJECTCLASS: [Filters.OC_PERSON],
            },
        ),
    ]


@pytest.fixture
def hierarchy_entries() -> list[FlextLdifModels.Entry]:
    """Create hierarchy/container entries."""
    return [
        create_entry(
            DNs.EXAMPLE,
            {"dc": ["example"], Filters.ATTR_OBJECTCLASS: [Filters.OC_DOMAIN]},
        ),
        create_entry(
            Filters.DN_OU_USERS,
            {
                "ou": ["users"],
                Filters.ATTR_OBJECTCLASS: [Filters.OC_ORGANIZATIONAL_UNIT],
            },
        ),
        create_entry(
            Filters.DN_OU_GROUPS,
            {
                "ou": ["groups"],
                Filters.ATTR_OBJECTCLASS: [Filters.OC_ORGANIZATIONAL_UNIT],
            },
        ),
    ]


@pytest.fixture
def mixed_entries() -> list[FlextLdifModels.Entry]:
    """Create mixed entry types for categorization."""
    return [
        create_entry(
            f"cn=users,ou=groups,{DNs.EXAMPLE}",
            {
                Filters.ATTR_CN: ["users"],
                Filters.ATTR_OBJECTCLASS: [Filters.OC_GROUP_OF_NAMES],
                "member": [Filters.DN_USER_JOHN],
            },
        ),
        create_entry(
            Filters.DN_ACL_POLICY,
            {
                Filters.ATTR_CN: ["acl-policy"],
                Filters.ATTR_OBJECTCLASS: ["device", "top"],
                "acl": ["grant(user1)"],
            },
        ),
        create_entry(
            Filters.DN_REJECTED,
            {
                Filters.ATTR_CN: ["rejected"],
                Filters.ATTR_OBJECTCLASS: ["device", "top"],
            },
        ),
    ]


@pytest.fixture
def schema_entries() -> list[FlextLdifModels.Entry]:
    """Create schema entries."""
    return [
        create_entry(
            DNs.SCHEMA,
            {
                Filters.ATTR_CN: ["schema"],
                "attributeTypes": [
                    f"( {OIDs.CN} NAME '{Names.CN}' EQUALITY caseIgnoreMatch )",
                ],
            },
        ),
        create_entry(
            DNs.SCHEMA,
            {
                Filters.ATTR_CN: ["schema"],
                "objectClasses": [
                    f"( {OIDs.PERSON} NAME '{Names.PERSON}' SUP top )",
                ],
            },
        ),
    ]


# ════════════════════════════════════════════════════════════════════════════
# TEST CLASSES - CONSOLIDATED AND PARAMETRIZED
# ════════════════════════════════════════════════════════════════════════════


class TestFilterOperations:
    """Test filter operation methods (by_dn, by_objectclass, etc.) with parametrization."""

    FILTER_SCENARIOS: ClassVar[set[FilterOperationScenario]] = {
        FilterOperationScenario.BY_DN_BASIC,
        FilterOperationScenario.BY_DN_CASE_INSENSITIVE,
        FilterOperationScenario.BY_DN_EXCLUDE_MODE,
        FilterOperationScenario.BY_OBJECTCLASS_BASIC,
        FilterOperationScenario.BY_OBJECTCLASS_MULTIPLE,
        FilterOperationScenario.BY_OBJECTCLASS_WITH_REQUIRED,
        FilterOperationScenario.BY_ATTRIBUTES_ANY,
        FilterOperationScenario.BY_ATTRIBUTES_ALL,
        FilterOperationScenario.BY_BASE_DN_BASIC,
        FilterOperationScenario.BY_BASE_DN_HIERARCHY,
    }

    @pytest.mark.parametrize(
        ("scenario",),
        [[s] for s in FILTER_SCENARIOS],
    )
    def test_filter_operations(
        self,
        scenario: FilterOperationScenario,
        user_entries: list[FlextLdifModels.Entry],
        hierarchy_entries: list[FlextLdifModels.Entry],
    ) -> None:
        """Test various filter operations with parametrization."""
        if scenario == FilterOperationScenario.BY_DN_BASIC:
            filtered = TestDeduplicationHelpers.filter_by_dn_and_unwrap(
                user_entries,
                Filters.DN_PATTERN_USERS,
                mark_excluded=True,
                expected_count=3,
                expected_dn_substring=",ou=users,",
            )
            matching = [e for e in filtered if e.dn and ",ou=users," in e.dn.value]
            assert len(matching) == 2

        elif scenario == FilterOperationScenario.BY_DN_CASE_INSENSITIVE:
            _ = TestDeduplicationHelpers.filter_by_dn_and_unwrap(
                user_entries,
                "*,OU=USERS,*",
                expected_count=2,
            )

        elif scenario == FilterOperationScenario.BY_DN_EXCLUDE_MODE:
            filtered = TestDeduplicationHelpers.filter_by_dn_and_unwrap(
                user_entries,
                Filters.DN_PATTERN_USERS,
                mode=Filters.MODE_EXCLUDE,
                expected_count=1,
            )
            TestDeduplicationHelpers.assert_entries_dn_contains(
                filtered,
                "ou=admins",
                all_entries=False,
            )

        elif scenario == FilterOperationScenario.BY_OBJECTCLASS_BASIC:
            _ = TestDeduplicationHelpers.filter_by_objectclass_and_unwrap(
                user_entries,
                Filters.OC_PERSON,
                expected_count=3,
            )

        elif scenario == FilterOperationScenario.BY_OBJECTCLASS_MULTIPLE:
            _ = TestDeduplicationHelpers.filter_by_objectclass_and_unwrap(
                user_entries,
                (Filters.OC_PERSON, Filters.OC_ORGANIZATIONAL_UNIT),
                expected_count=3,
            )

        elif scenario == FilterOperationScenario.BY_OBJECTCLASS_WITH_REQUIRED:
            _ = TestDeduplicationHelpers.filter_by_objectclass_and_unwrap(
                user_entries,
                Filters.OC_PERSON,
                required_attributes=[Filters.ATTR_MAIL],
                expected_count=3,
            )

        elif scenario == FilterOperationScenario.BY_ATTRIBUTES_ANY:
            _ = TestDeduplicationHelpers.filter_by_attributes_and_unwrap(
                user_entries,
                [Filters.ATTR_MAIL],
                match_all=False,
                expected_count=3,
            )

        elif scenario == FilterOperationScenario.BY_ATTRIBUTES_ALL:
            entries = [
                create_entry(
                    "cn=e1,dc=x",
                    {
                        Filters.ATTR_CN: ["e1"],
                        Filters.ATTR_MAIL: ["e1@x"],
                        "phone": ["123"],
                    },
                ),
                create_entry(
                    "cn=e2,dc=x",
                    {
                        Filters.ATTR_CN: ["e2"],
                        Filters.ATTR_MAIL: ["e2@x"],
                    },
                ),
            ]
            TestDeduplicationHelpers.filter_by_attributes_and_unwrap(
                entries,
                [Filters.ATTR_MAIL, "phone"],
                match_all=True,
                expected_count=1,
            )

        elif scenario == FilterOperationScenario.BY_BASE_DN_BASIC:
            included, excluded = FlextLdifFilters.by_base_dn(
                hierarchy_entries,
                DNs.EXAMPLE,
            )
            assert len(included) == 3
            assert len(excluded) == 0

        elif scenario == FilterOperationScenario.BY_BASE_DN_HIERARCHY:
            entries = [
                create_entry(
                    DNs.EXAMPLE,
                    {"dc": ["example"]},
                ),
                create_entry(
                    Filters.DN_OU_USERS,
                    {"ou": ["users"]},
                ),
                create_entry(
                    Filters.DN_USER_JOHN,
                    {Filters.ATTR_CN: ["john"]},
                ),
                create_entry("dc=other,dc=org", {"dc": ["other"]}),
            ]
            included, excluded = FlextLdifFilters.by_base_dn(
                entries,
                DNs.EXAMPLE,
            )
            assert len(included) == 3
            assert len(excluded) == 1


class TestCategorization:
    """Test categorization operations with parametrization."""

    CATEGORIZATION_SCENARIOS: ClassVar[set[CategorizationScenario]] = {
        CategorizationScenario.CATEGORY_USERS,
        CategorizationScenario.CATEGORY_GROUPS,
        CategorizationScenario.CATEGORY_HIERARCHY,
        CategorizationScenario.CATEGORY_SCHEMA,
        CategorizationScenario.CATEGORY_ACL,
        CategorizationScenario.CATEGORY_REJECTED,
    }

    @pytest.mark.parametrize(
        ("scenario",),
        [[s] for s in CATEGORIZATION_SCENARIOS],
    )
    def test_categorize_scenarios(
        self,
        scenario: CategorizationScenario,
    ) -> None:
        """Test categorize() with different categories."""
        if scenario == CategorizationScenario.CATEGORY_USERS:
            entry = create_entry(
                Filters.DN_USER_JOHN,
                {
                    Filters.ATTR_CN: ["john"],
                    Filters.ATTR_MAIL: ["john@example.com"],
                    Filters.ATTR_OBJECTCLASS: [Filters.OC_PERSON],
                },
            )
            rules: Mapping[str, object] = {
                "user_objectclasses": [Filters.OC_PERSON],
                "hierarchy_objectclasses": [Filters.OC_ORGANIZATIONAL_UNIT],
            }
            expected = "users"

        elif scenario == CategorizationScenario.CATEGORY_HIERARCHY:
            entry = create_entry(
                Filters.DN_OU_USERS,
                {
                    "ou": ["users"],
                    Filters.ATTR_OBJECTCLASS: [Filters.OC_ORGANIZATIONAL_UNIT],
                },
            )
            rules = {
                "hierarchy_objectclasses": [Filters.OC_ORGANIZATIONAL_UNIT],
                "user_objectclasses": [Filters.OC_PERSON],
            }
            expected = "hierarchy"

        elif scenario == CategorizationScenario.CATEGORY_GROUPS:
            entry = create_entry(
                "cn=admins,ou=groups,dc=example,dc=com",
                {
                    Filters.ATTR_CN: ["admins"],
                    Filters.ATTR_OBJECTCLASS: [Filters.OC_GROUP_OF_NAMES],
                    "member": [Filters.DN_USER_JOHN],
                },
            )
            rules = {
                "group_objectclasses": [Filters.OC_GROUP_OF_NAMES],
                "user_objectclasses": [Filters.OC_PERSON],
            }
            expected = "groups"

        elif scenario == CategorizationScenario.CATEGORY_SCHEMA:
            entry = create_entry(
                DNs.SCHEMA,
                {
                    Filters.ATTR_CN: ["schema"],
                    "attributeTypes": [
                        f"( {OIDs.CN} NAME '{Names.CN}' EQUALITY caseIgnoreMatch )",
                    ],
                },
            )
            rules = {}
            expected = "schema"

        elif scenario == CategorizationScenario.CATEGORY_ACL:
            entry = create_entry(
                Filters.DN_ACL_POLICY,
                {Filters.ATTR_CN: ["policy"], "aci": ["grant(user1)"]},
            )
            rules = {"acl_attributes": ["aci"]}
            expected = "acl"

        else:  # REJECTED
            entry = create_entry(
                Filters.DN_REJECTED,
                {
                    Filters.ATTR_CN: ["unknown"],
                    Filters.ATTR_OBJECTCLASS: ["device", "top"],
                },
            )
            rules = {}
            expected = "rejected"

        result_category, _reason = FlextLdifFilters.categorize(
            entry,
            rules,
            server_type=(
                Filters.SERVER_OUD
                if scenario == CategorizationScenario.CATEGORY_ACL
                else Filters.SERVER_RFC
            ),
        )
        assert result_category == expected


class TestTransformations:
    """Test transformation operations with parametrization."""

    TRANSFORMATION_SCENARIOS: ClassVar[set[TransformationScenario]] = {
        TransformationScenario.REMOVE_ATTRIBUTES,
        TransformationScenario.REMOVE_OBJECTCLASSES,
    }

    @pytest.mark.parametrize(
        ("scenario",),
        [[s] for s in TRANSFORMATION_SCENARIOS],
    )
    def test_transformation_scenarios(
        self,
        scenario: TransformationScenario,
    ) -> None:
        """Test transformation operations with parametrization."""
        if scenario == TransformationScenario.REMOVE_ATTRIBUTES:
            entry = create_entry(
                "cn=test,dc=x",
                {
                    Filters.ATTR_CN: ["test"],
                    Filters.ATTR_MAIL: ["test@x"],
                    Filters.ATTR_OBJECTCLASS: [Filters.OC_PERSON],
                },
            )
            TestDeduplicationHelpers.remove_attributes_and_validate(
                entry,
                [Filters.ATTR_MAIL],
                must_still_have=[Filters.ATTR_CN],
            )

        elif scenario == TransformationScenario.REMOVE_OBJECTCLASSES:
            entry = create_entry(
                "cn=test,dc=x",
                {
                    Filters.ATTR_CN: ["test"],
                    Filters.ATTR_OBJECTCLASS: [Names.TOP, Filters.OC_PERSON],
                },
            )
            TestDeduplicationHelpers.remove_objectclasses_and_validate(
                entry,
                [Filters.OC_PERSON],
                must_still_have=[Names.TOP],
            )


class TestSchemaOperations:
    """Test schema detection and operations with parametrization."""

    SCHEMA_SCENARIOS: ClassVar[set[SchemaOperationScenario]] = {
        SchemaOperationScenario.IS_SCHEMA_DETECTION,
        SchemaOperationScenario.IS_SCHEMA_NON_SCHEMA,
        SchemaOperationScenario.EXTRACT_ACL_ENTRIES,
    }

    @pytest.mark.parametrize(
        ("scenario",),
        [[s] for s in SCHEMA_SCENARIOS],
    )
    def test_schema_scenarios(
        self,
        scenario: SchemaOperationScenario,
        schema_entries: list[FlextLdifModels.Entry],
        mixed_entries: list[FlextLdifModels.Entry],
        user_entries: list[FlextLdifModels.Entry],
    ) -> None:
        """Test schema operations with parametrization."""
        if scenario == SchemaOperationScenario.IS_SCHEMA_DETECTION:
            assert FlextLdifFilters.is_schema(schema_entries[0])
            assert FlextLdifFilters.is_schema(schema_entries[1])

        elif scenario == SchemaOperationScenario.IS_SCHEMA_NON_SCHEMA:
            assert not FlextLdifFilters.is_schema(user_entries[0])

        elif scenario == SchemaOperationScenario.EXTRACT_ACL_ENTRIES:
            result = FlextLdifFilters.extract_acl_entries(mixed_entries)
            acl_entries = FlextTestsMatchers.assert_success(
                result,
                f"Extract ACL failed: {result.error}",
            )
            assert len(acl_entries) == 1
            assert acl_entries[0].attributes
            assert "acl" in acl_entries[0].attributes.attributes


class TestEdgeCases:
    """Test edge cases with parametrization."""

    EDGE_SCENARIOS: ClassVar[set[EdgeCaseScenario]] = {
        EdgeCaseScenario.EMPTY_ENTRIES,
        EdgeCaseScenario.SINGLE_ENTRY,
        EdgeCaseScenario.LARGE_ENTRY_LIST,
        EdgeCaseScenario.FILTER_WITH_EMPTY_ATTRS,
    }

    @pytest.mark.parametrize(
        ("scenario",),
        [[s] for s in EDGE_SCENARIOS],
    )
    def test_edge_case_scenarios(
        self,
        scenario: EdgeCaseScenario,
        user_entries: list[FlextLdifModels.Entry],
    ) -> None:
        """Test edge cases with parametrization."""
        if scenario == EdgeCaseScenario.EMPTY_ENTRIES:
            filtered = TestDeduplicationHelpers.filter_by_dn_and_unwrap(
                [],
                "cn=test,dc=x",
                expected_count=0,
            )
            assert len(filtered) == 0

        elif scenario == EdgeCaseScenario.SINGLE_ENTRY:
            result = FlextLdifFilters.by_dn([user_entries[0]], "*")
            assert result.is_success

        elif scenario == EdgeCaseScenario.LARGE_ENTRY_LIST:
            large_list = [
                create_entry(
                    f"cn=user{i},dc=example,dc=com",
                    {
                        Filters.ATTR_CN: [f"user{i}"],
                        Filters.ATTR_OBJECTCLASS: [Filters.OC_PERSON],
                    },
                )
                for i in range(100)
            ]
            result = FlextLdifFilters.by_dn(large_list, "*")
            assert result.is_success

        elif scenario == EdgeCaseScenario.FILTER_WITH_EMPTY_ATTRS:
            entry = create_entry(
                "cn=test,dc=x",
                {
                    Filters.ATTR_CN: ["test"],
                    Filters.ATTR_OBJECTCLASS: [Filters.OC_PERSON],
                },
            )
            result = FlextLdifFilters.filter_entry_attributes(
                entry,
                [],  # empty attributes
            )
            assert result.is_success


__all__ = [
    "CategorizationScenario",
    "EdgeCaseScenario",
    "FilterOperationScenario",
    "SchemaOperationScenario",
    "TestCategorization",
    "TestEdgeCases",
    "TestFilterOperations",
    "TestSchemaOperations",
    "TestTransformations",
    "TransformationScenario",
]
